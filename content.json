{"pages":[{"title":"分類","text":"","link":"/ioioy77.github.io/categories/index.html"},{"title":"標籤","text":"","link":"/ioioy77.github.io/tags/index.html"},{"title":"關於我","text":"非本科生前端工程師目前正努力精進自己的技術中","link":"/ioioy77.github.io/about/index.html"}],"posts":[{"title":"Hoisting","text":"JavaScript 在執行時會分為兩個部分，一為創造環境，一為執行。 變數 創造階段先被挑出來，並在記憶體上給個空間 執行階段賦值 1234567// 以下面程式碼為例var hp = 'Harry Potter';// 創造var hp;// 執行hp = 'Harry Potter'; 函式 創造階段函式陳述式：優先載入函式表達式：情形同變數 執行階段函式陳述式：在創造階段就已能運行函式表達式：賦值 1234567891011121314// 以下面程式碼為例(函式陳述式)hp1();function hp1() { console.log(\"Harry Potter and the Philosopher's Stone\");}// 創造function hp1() { console.log(\"Harry Potter and the Philosopher's Stone\");}// 執行hp1();// Harry Potter and the Philosopher's Stone 1234567891011121314// 以下面程式碼為例(函式表達式)hp1();var hp1 = function() { console.log(\"Harry Potter and the Philosopher's Stone\");}// 創造var hp1;// 執行hp1 = function() { console.log(\"Harry Potter and the Philosopher's Stone\");}// error，顯示 hp1 is not a function 範例 1 123456789function hp() { console.log('Harry Potter lose the battle.');}var hp = function() { console.log('Harry Potter win the battle.');}hp();// Harry Potter win the battle. 在以上範例中，不論是陳述式放前還是表達式放前，hp()的結果都是Harry Potter win the battle.。以提升的拆解來看， 1234567891011// 創造function hp() {} console.log('Harry Potter lose the battle.');}var hp;// 執行hp = function() { console.log('Harry Potter win the battle.');}hp(); 在執行階段hp()被賦予了一個新值，覆蓋掉了前面的值，所以此題的答案永遠都是Harry Potter win the battle.。 範例 2 1234567891011function theBoyWhoLived() { console.log('Neville Longbottom');}theBoyWhoLived();function theBoyWhoLived() { console.log('Harry Potter');}theBoyWhoLived();// Harry Potter// Harry Potter 以上的範例中，兩次執行theBoyWhoLived();得出的結果都是Harry Potter。以提升的拆解來看， 12345678910// 創造function theBoyWhoLived() { console.log('Neville Longbottom');}function theBoyWhoLived() { console.log('Harry Potter');}// 執行theBoyWhoLived();theBoyWhoLived(); 這樣，為什麼兩次執行結果都是Harry Potter是不是就很清楚了呢~","link":"/ioioy77.github.io/2019/10/11/Hoisting/"},{"title":"Vue Instance","text":"前言Vue 音似 View，用意為表示 Vue.js 專注於 View。和其他實作 MVC 的 JavaScript 框架 ( Angular.js、Ember.js ) 相比，Vue.js 屬於 MVVM 設計模式的實作。 MVVM 由 Model–View–ViewModel 組成，使用者看到的是 View，Model 則是資料，View 會和 ViewModel 做資料綁定，然後由 ViewModel 去存取資料，也就是說 View 不會直接存取 Model (資料)，而是由 ViewModel 來做，它是一個同步 View 和 Model 的物件，Vue.js 主要就是在做 ViewModel 的工作。它讓 View 來和它綁定，然後當 Model 發生變化時，自動反應到 View 上。 原生的 JavaScript 或是 jQurey，必須先取得元素才能插入資料，Vue.js 則將 HTML 當成模板，藉由 el 屬性來確認它的執行範圍，然後將資料傳給模板，處理後呈現最後看到的 View。所有 View 的設計，全都在 HTML 中做好，並指定要放資料的區域，Vue.js 便會自動把資料放入其中。 創建實體每個 Vue 的應用皆始於使用 Vue function 建構一個新的 Vue 實體。 123var vm = new Vue({ // options}) 由於受到 MVVM 影響，是以習慣使用變數 vm (ViewModel 的縮寫) 來表示 Vue 實體。 基礎型態實體內 el 參數為 DOM id (指定 id 外不受此實體影響)，data 用於定義屬性：author、series、character，methods 定義函式，可通過 return 返回值，鬍子語法輸出屬性值或函式返回值。 123456789101112131415161718&lt;div id=\"\"&gt; {{ 屬性名稱 }}&lt;/div&gt;new Vue( // 傳入物件 { el: 'DOM id', // data 的值為物件格式或函式，通常會直接用物件，但在計算屬性只能使用函式 data: { // 屬性名稱自訂，用來和 HTML 模板中的 {{ 屬性名稱 }} 相對應。 屬性名稱: '屬性值' }, method: { // 設定 function } }) 實體範例1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue Instance&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"vue_instance\"&gt; &lt;h1&gt;author : {{ author }}&lt;/h1&gt; &lt;h1&gt;series : {{ series }}&lt;/h1&gt; &lt;h1&gt;{{ details() }}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue_instance', data: { author: \"Andrzej Sapkowski\", series: \"The Witcher\", character: [ 'Geralt of Rivia', 'Cirilla Fiona Elen Riannon, the Lion Cub of Cintra' ] }, methods: { details: function() { return this.author + ' writes a series about ' + this.character[0] + ' and ' + this.character[1] + '.'; } } }) &lt;/script&gt;&lt;/body&gt; 運行結果123author : Andrzej Sapkowskiseries : The WitcherAndrzej Sapkowski writes a series about Geralt of Rivia and Cirilla Fiona Elen Riannon, the Lion Cub of Cintra. 響應式狀態當一個 Vue 實體被創建時，它將 data 對象中的所有的屬性加入到 Vue 的響應式系統中。若屬性的值發生改變，頁面將會更新為新的值。 123456789101112var obj = { a: 1 }var vm = new Vue({ data: obj})// 指針相同vm.a === obj.a // true// 修改設置屬性會影響原始數據vm.a = 2obj.a // 2// 無論更動哪方原始數據都會被修改obj.a = 3vm.a // 3 僅有實體被創建時就已經存在於 data 中的屬性才是響應式的。若是之後才新增的屬性，比如： 1vm.b = &apos;I am new！&apos; 則對 b 的改動不會觸發頁面更新。所以一個 Vue 實體在未來所會使用到的所有屬性在最開始時就須全部設定完畢(初始設定為空或不存在：””、0、false、[]、null)。 ※ 使用 Object.freeze() 能阻止修改現有屬性，並導致響應系統無法再追蹤變化。 Vue 所提供的屬性及方法Vue 實體提供了一些能夠被存取的屬性與方法，並以前綴 $ 與用戶自定義的屬性區分。 範例12345678910111213141516171819202122232425262728&lt;div id=\"vm\"&gt; {{a}}&lt;/div&gt;&lt;script&gt;var vm = new Vue({ el: '#vm', data: { a: 'Hello World！' }})// 取得的 el 屬性和用 JavaScript 方法取得的元素相同vm.$el === document.querySelector('#vm') // true// 取得資料物件的屬性console.log(vm.a) // Hello World！// 呼叫 watch 方法，當 a 的值改變時觸發vm.$watch('a', function(newVal, oldVal){ console.log('a 現在是 ' + newVal + ', 之前是' + oldVal) // a 現在是 change！, 之前是 Hello World！})// 模擬 2 秒後改變 a 的值，並觸發 vm.$watch() 方法setTimeout(function(){ vm.a = 'change！'}, 2000)&lt;/script&gt;","link":"/ioioy77.github.io/2020/02/08/Vue Instance/"},{"title":"Vue Lifecycle","text":"Vue 實體在被創建時會經過一系列初始化的步驟，如數據監聽、編譯模板、掛載實體、綁定資料等。與此同時 Vue 也提供了讓使用者能在特定階段自行客製化程式碼的方法，這些方法就稱為 Lifecycle Hook。 生命週期掛鉤創建階段 beforeCreate：實體建構前。 Created：實體建構後調用，此時 Vue 實體內除 $el 外皆已配置(可取得並處理)。 掛載階段 beforeMount：渲染至 template 之前。 mounted：$el 配置與渲染。 此鉤子無法保證所有的子組件也都一起被掛載。如果希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick 12345mounted: function () { this.$nextTick(function () { // 視圖渲染完畢後執行 })} 資料更新階段 beforeUpdate：資料變化後，視圖改變前。 updated：視圖更新後調用。多數情況下應避免在此期間更改狀態。如需改變相應狀態，通常最好使用計算屬性或是 watcher。 此鉤子無法保證所有的子組件也都一起被重繪。如果希望等到整個視圖都重繪完畢，可以在 updated 裏使用 vm.$nextTick 12345updated: function () { this.$nextTick(function () { // 視圖渲染完畢後執行 })} 刪除階段 beforeDestroy：實體銷毀前調用。 destroyed：實體銷毀後調用。 保存/緩存狀態 activated：keep-alive 觸發時調用。 deactivated：keep-alive 停用時調用。 ※ 若有設定 &lt;keep-alive&gt;，則只會有 activated Hook 與 deactivated Hook，而不觸發 destroyed Hook。 錯誤處理 errorCaptured：捕獲子孫組件的錯誤時調用。 此鉤子會收到三個參數：錯誤對象、發生錯誤的組件實體以及一個包含錯誤來源信息的字符串。並返回 false 以阻止該錯誤繼續向上傳播。 範例12345&lt;div id=&quot;app&quot;&gt; {{ Lifecycle }} &lt;button v-on:click=&quot;Lifecycle++&quot;&gt;add&lt;/button&gt; &lt;button v-on:click=&quot;$destroy()&quot;&gt;Destroy instance&lt;/button&gt;&lt;/div&gt; 初始化時 12345678910111213141516171819202122232425262728293031323334353637383940var vm = new Vue({ el: '#app', data: { Lifecycle: 1 }, // 實體被 constructor 建立前 beforeCreate() { console.log('beforeCreate'); console.log(`this.Lifecycle: ${this.Lifecycle}`); // undefined console.log(`this.$el: ${this.$el}`); // undefined console.log(); }, // 實體被 constructor 建立後，在這裡完成 data binding created() { console.log('created'); console.log(`this.Lifecycle: ${this.Lifecycle}`); // 1 console.log(`this.$el: ${this.$el}`); // undefined console.log(); }, // 綁定 DOM 之前 beforeMount() { console.log('beforeMount'); console.log(this.$el.outerHTML); // &lt;div id='app'&gt; // {{ Lifecycle }} // &lt;button v-on:click='Lifecycle++'&gt;add&lt;/button&gt; // &lt;button v-on:click='$destroy()'&gt;Destroy instance&lt;/button&gt; // &lt;/div&gt; console.log(); }, // 綁定 DOM 之後 mounted() { console.log('mounted'); console.log(this.$el.outerHTML); // &lt;div id='app'&gt; // 1 // &lt;button&gt;add&lt;/button&gt; &lt;button&gt;Destroy instance&lt;/button&gt;&lt;/div&gt; console.log(); },}); 按下 add 後 1234567891011121314151617181920212223242526var vm = new Vue({ el: '#app', data: { Lifecycle: 1 }, // 資料更新，但尚未更新 DOM beforeUpdate() { console.log('beforeUpdate'); console.log(`this.Lifecycle: ${this.Lifecycle}`); // 2 console.log(this.$el.outerHTML); // &lt;div id='app'&gt; // 1 // &lt;button&gt;add&lt;/button&gt; &lt;button&gt;Destroy instance&lt;/button&gt;&lt;/div&gt; console.log(); }, // 資料更新，並更新 DOM updated() { console.log('updated'); console.log(`this.Lifecycle: ${this.Lifecycle}`); // 2 console.log(this.$el.outerHTML); // &lt;div id='app'&gt; // 2 // &lt;button&gt;add&lt;/button&gt; &lt;button&gt;Destroy instance&lt;/button&gt;&lt;/div&gt; console.log(); },}); 按下 Destroy instance 後 12console.log(`this.Lifecycle: ${this.Lifecycle}`); // undefinedconsole.log(`this.$el: ${this.$el}`); // undefined 生命週期圖示","link":"/ioioy77.github.io/2020/02/15/Vue Lifecycle/"},{"title":"Vue Template_Syntax - basic","text":"模板語法-基礎篇 插值文本使用鬍子插值，HTML 的鬍子標籤(雙大括號)內會被填入 data 裡相對應的值。 1234567891011&lt;div id=\"app\"&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data: { message: 'Hello World!' }}) 運行結果：Hello World! HTML如果打算插入 HTML 而不是純文本，不能使用鬍子 123456789101112&lt;div id=\"app\"&gt; &lt;div&gt;{{ message }}&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { message: '&lt;span style=\"color:red\"&gt;Hello World!&lt;/span&gt;' }})&lt;/script&gt; 運行結果會是這樣：&lt;span style=”color:red”&gt;Hello World!&lt;/span&gt; 鬍子標籤無法讀取 HTML，要讀取 HTML 只能使用 v-html 123456789101112&lt;div id=\"app\"&gt; &lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { message: '&lt;span style=\"color:red\"&gt;Hello World!&lt;/span&gt;' }})&lt;/script&gt; 運行結果：Hello World! ※ 注意 Hello World! 此時已經是 &lt;span&gt; 而不是 &lt;div&gt; 了 屬性鬍子語法同樣不能作用在 HTML attribute 上，要在 HTML 屬性裡插入資料，必須使用 v-bind 語法 123456789101112&lt;div id=\"app\"&gt; &lt;input v-bind:placeholder='vbind'&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data:{ vbind: '請輸入文字' }});&lt;/script&gt; 運行結果： MDN-HTML attribute reference 表達式鬍子內還可以放 javascript 表達式 12345678910111213141516&lt;div id=\"app\"&gt; {{ number + 1 }}&lt;br&gt; {{ prize ? '中獎！' : '沒中' }}&lt;br&gt; {{ message.split('').reverse().join('') }}&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { prize: true, message: '！dlroW olleH', number: 8 }})&lt;/script&gt; 運行結果：9中獎！Hello World！ 指令帶有 v- 前綴的特殊 attribute。attribute 的預期值是單個 JavaScript 表達式 (v-for 例外)。當表達式的值改變時，指令會將改變的值響應式地作用於 DOM。 參數部分指令能夠接收參數，參數位置放在指令後並以冒號連接。 12&lt;!-- 響應式更新 HTML attribute --&gt;&lt;a v-bind:herf=&quot;url&quot;&gt;...&lt;/a&gt; 12&lt;!-- 監聽 DOM 事件 --&gt;&lt;button v-on:click=&quot;fn&quot;&gt;...&lt;/button&gt; 動態參數參數能夠以 javascript 表達式動態求值 1&lt;a v-bind:[attributeName]=&quot;url&quot;&gt;...&lt;/a&gt; 1&lt;button v-on:[eventName]=&quot;doSomething&quot;&gt;...&lt;/button&gt; 值的限制動態參數所求的值必須要是字串，特殊情況下值為 null，並且可以依據 null 狀態來解除綁定，除此之外其他任何型態的值都會觸發警告。 表達式的限制空格與引號在動態參數內是無效的，請使用模板字串或是計算屬性代替。 12345&lt;!-- 無效寫法 --&gt;&lt;div :[key + &apos;foo&apos;]=&quot;value&quot;&gt;&lt;/div&gt;&lt;!-- 正確寫法 --&gt;&lt;div :[`${key}foo`]=&quot;value&quot;&gt;&lt;/div&gt; 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;div :[idorclass()]=\"'test'\"&gt;Testing&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue({ el: \"#app\", methods: { idorclass() { // Just a \"random\" behavior return new Date().getTime() % 2 == 0 ? \"id\" : \"class\"; } } });&lt;/script&gt;// source: https://openbox.pt/vuejs/vue-js-2-6-dynamic-directive-arguments/ 瀏覽器會自動把 HTML attribute 轉成小寫，所以在實體的 property(屬性名稱) 內記得必須使用小寫，否則程式碼不會生效。 123456789101112&lt;div id=\"app\"&gt; &lt;a v-bind:[attributeName]=\"url\"&gt;Link&lt;/a&gt;&lt;/div&gt;new Vue({ el: '#app', data: { attributename: 'href', // lowercase url: 'http://vuejs.org', } }}); 縮寫v-bind 與 v-on 作為最常用的兩個指令，擁有自己的縮寫。 1234&lt;!-- 完整語法 --&gt;&lt;a v-bind:herf=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 縮寫 --&gt;&lt;a :herf=&quot;url&quot;&gt;...&lt;/a&gt; 1234&lt;!-- 完整語法 --&gt;&lt;button v-on:click=&quot;fn&quot;&gt;...&lt;/button&gt;&lt;!-- 縮寫 --&gt;&lt;button @click=&quot;fn&quot;&gt;...&lt;/button&gt;","link":"/ioioy77.github.io/2020/02/21/Vue Template_Syntax-basic/"},{"title":"Vue Class and Style Bindings","text":"class 與 style 皆是屬性，在 HTML 屬性裡帶入資料，用的是 v-bind 語法。通常來說 v-bind 的屬性值為字串，為了操作的方便，Vue 另外增強了 class 與 style 綁定的功能。 Class物件語法傳給 v-bind:class 一個物件，動態切換 class 12345678910&lt;div id=\"app\"&gt; &lt;div class=\"sth\" v-bind:class=\"{ 'text-danger': hasError }\"&gt;一些警告&lt;/div&gt;&lt;/div&gt;var vm = new Vue({ el: '#app' data: { hasError: true }}) HTML 會渲染成： 1&lt;div class=&quot;sth text-danger&quot;&gt;一些警告&lt;/div&gt; 視圖顯示：一些警告 如果 vm.hasError = false 則：一些警告 也可以這樣寫： 12345678&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;data: { classObject: { 'text-danger': true, 'text-primary': false }} 或是使用計算屬性 1234567891011121314&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;data: { 'text-danger': true, 'text-primary': false},computed: { classObject: function () { return { 'text-danger': // 表達式, 'text-primary': // 表達式 } }} 陣列語法傳給 v-bind:class 一個陣列，帶入多個 class 123456&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;data: { activeClass: 'active', errorClass: 'text-danger'} HTML 會渲染成： 1&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 若是想根據真值假值切換列表內的 class，可以使用三元運算 1&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt; 或是直接用物件語法 1&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt; 元件在自定義元件上使用屬性 class 時，所使用的 class 將被添加到元件根元素上，原本位於根元素上的 class 不會被覆蓋。 123Vue.component('my-component', { template: '&lt;p class=\"classA classB\"&gt;Hi&lt;/p&gt;'}) 添加 class 1&lt;my-component class=&quot;classC classD&quot;&gt;&lt;/my-component&gt; HTML 會渲染成： 1&lt;p class=&quot;classA classB classC classD&quot;&gt;Hi&lt;/p&gt; 用物件語法也行 1&lt;my-component v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/my-component&gt; 若 isActive 為真值，則 1&lt;p class=&quot;classA classB active&quot;&gt;Hi&lt;/p&gt; Style物件語法css 屬姓名可用 駝峰式(camelCase) 或 橫線(kebab-case) 來命名，橫線記得包在引號內。 123456&lt;div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt;data: { activeColor: 'red', fontSize: 30} 下面寫法更優 12345678&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt;data: { styleObject: { color: 'red', fontSize: '13px' }} 又或是搭配返回物件的計算屬性使用。 陣列語法帶入多個 style 物件。 12345678910&lt;div v-bind:style=&quot;[colorStyle, sizeStyle]&quot;&gt;紅30&lt;/div&gt;data: { colorStyle: { color: &apos;red&apos; }, sizeStyle: { &apos;font-size&apos;: &apos;30px&apos; }} 視圖顯示：紅30","link":"/ioioy77.github.io/2020/02/28/Vue v-bind plus/"},{"title":"Vue Computed Properties","text":"模板內的表達式做不到的就交給計算屬性吧。也就是說，任何複雜的邏輯都應該交給計算屬性。 基礎範例123456789101112131415161718&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"{{ message }}\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"{{ reversedMessage }}\"&lt;/p&gt;&lt;/div&gt;var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 計算屬性的 getter reversedMessage: function () { // this 指向 vm 實體 return this.message.split('').reverse().join('') } }}) 結果：Original message: “Hello”Computed reversed message: “olleH” 緩存使用方法其實也可以達到計算屬性的效果： 12345678910111213141516171819202122&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"{{ message }}\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"{{ reversedMessage }}\"&lt;/p&gt; &lt;p&gt;Methods reversed message: \"{{ reversed() }}\"&lt;/p&gt;&lt;/div&gt;var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } }, methods: { reversed: function () { return this.message.split('').reverse().join('') } }}) 結果：Original message: “Hello”Computed reversed message: “olleH”Methods reversed message: “olleH” 計算屬性與方法的差異在於是否有緩存。對於計算屬性來說，如果它所依賴的資料(以上面為例，就是 message)沒有改變，那麼它就不會重新求值，只會返回上次的計算結果；而調用方法則是每次觸發重新渲染都會重新求一次值。所以如果現在有一個十分耗性能的函式，並且它不需用時時刷新，那麼最好就使用計算屬性，而當不希望有緩存時，就改成使用方法。 setter計算屬性默認只有 getter，但也能自設 setter 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;div&gt;{{ fullName }}&lt;/div&gt;&lt;/div&gt;var vm = new Vue({ el: '#app', data: { firstName: 'Clark', lastName: 'Kent' }, computed: { fullName: { // getter get: function () { return this.firstName + ' ' + this.lastName }, // setter set: function (newValue) { var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } } } })// vm.fullName = 'Kal El' 結果：Clark Kent如果解開最後一行的註解，setter 會被調用，data 會更新，結果：Kal El","link":"/ioioy77.github.io/2020/03/07/Vue Computed Properties/"},{"title":"Vue Conditional Rendering","text":"這次來介紹 Vue 的條件性渲染，主要的指令有 v-if 和 v-show。 v-ifv-if 指令用於條件性的渲染一個區塊的內容，僅在表達式的回傳值為 truthy 時渲染，若是初始條件為 false 時則不會進行(惰性求值)。因為會在切換時執行事件監聽和子元件的銷毀和重建，使用 v-if 的時機通常為運行條件很少改變時。 123456789101112&lt;div id=\"app\"&gt; &lt;p v-if=\"seen\"&gt;現在渲染 v-if&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { seen: true }})&lt;/script&gt; 視圖：現在渲染 v-if ※ 除了普通的 block 外，v-if 也能作用在 上 v-elsev-if 的 else 語法，必須要緊接在 v-if 或是 v-else-if 後，才能被識別。 12345678910111213&lt;div id=\"app\"&gt; &lt;p v-if=\"seen\"&gt;現在渲染 v-if&lt;/p&gt; &lt;p v-else&gt;現在渲染 v-else&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { seen: false }})&lt;/script&gt; 視圖：現在渲染 v-else v-else-ifv-if 的 else-if 語法，同 v-else，必須要緊接在 v-if 或是 v-else-if 後，才能被識別。 123456789101112131415&lt;div id=\"app\"&gt; &lt;div v-if=\"type === 'A'\"&gt;顯示A&lt;/div&gt; &lt;div v-else-if=\"type === 'B'\"&gt;顯示B&lt;/div&gt; &lt;div v-else-if=\"type === 'C'\"&gt;顯示C&lt;/div&gt; &lt;div v-else&gt;非 A/B/C&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { type: 'B' }})&lt;/script&gt; 視圖：顯示B v-showv-show 指令也是條件性的渲染一個區塊的內容，語法和 v-if 幾乎相同，和 v-if 不同的地方在於，v-show 始終都會渲染，並且表達式回傳的結果是用來切換 css 的 display，而不是決定是否渲染。因此，使用 v-show 的時機大多在需要頻繁切換塊作用域時。 123456789101112&lt;div id=\"app\"&gt; &lt;p v-show=\"seen\"&gt;Hello World&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue({ el: '#app', data: { seen: true }})&lt;/script&gt; ※ v-show 不能接著使用 v-else，也無法作用在 &lt;template&gt; 上","link":"/ioioy77.github.io/2020/03/15/Vue Conditional Rendering/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/ioioy77.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/ioioy77.github.io/tags/Vue/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/ioioy77.github.io/tags/w3HexSchool/"}],"categories":[{"name":"前端學習筆記","slug":"前端學習筆記","link":"/ioioy77.github.io/categories/前端學習筆記/"}]}