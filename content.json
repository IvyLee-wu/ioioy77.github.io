{"pages":[{"title":"分類","text":"","link":"/ioioy77.github.io/categories/index.html"},{"title":"標籤","text":"","link":"/ioioy77.github.io/tags/index.html"},{"title":"關於我","text":"非本科生前端工程師目前正努力精進自己的技術中","link":"/ioioy77.github.io/about/index.html"}],"posts":[{"title":"Hoisting","text":"JavaScript 在執行時會分為兩個部分，一為創造環境，一為執行。 變數 創造階段先被挑出來，並在記憶體上給個空間 執行階段賦值 1234567// 以下面程式碼為例var hp = 'Harry Potter';// 創造var hp;// 執行hp = 'Harry Potter'; 函式 創造階段函式陳述式：優先載入函式表達式：情形同變數 執行階段函式陳述式：在創造階段就已能運行函式表達式：賦值 1234567891011121314// 以下面程式碼為例(函式陳述式)hp1();function hp1() { console.log(\"Harry Potter and the Philosopher's Stone\");}// 創造function hp1() { console.log(\"Harry Potter and the Philosopher's Stone\");}// 執行hp1();// Harry Potter and the Philosopher's Stone 1234567891011121314// 以下面程式碼為例(函式表達式)hp1();var hp1 = function() { console.log(\"Harry Potter and the Philosopher's Stone\");}// 創造var hp1;// 執行hp1 = function() { console.log(\"Harry Potter and the Philosopher's Stone\");}// error，顯示 hp1 is not a function 範例 1 123456789function hp() { console.log('Harry Potter lose the battle.');}var hp = function() { console.log('Harry Potter win the battle.');}hp();// Harry Potter win the battle. 在以上範例中，不論是陳述式放前還是表達式放前，hp()的結果都是Harry Potter win the battle.。以提升的拆解來看， 1234567891011// 創造function hp() {} console.log('Harry Potter lose the battle.');}var hp;// 執行hp = function() { console.log('Harry Potter win the battle.');}hp(); 在執行階段hp()被賦予了一個新值，覆蓋掉了前面的值，所以此題的答案永遠都是Harry Potter win the battle.。 範例 2 1234567891011function theBoyWhoLived() { console.log('Neville Longbottom');}theBoyWhoLived();function theBoyWhoLived() { console.log('Harry Potter');}theBoyWhoLived();// Harry Potter// Harry Potter 以上的範例中，兩次執行theBoyWhoLived();得出的結果都是Harry Potter。以提升的拆解來看， 12345678910// 創造function theBoyWhoLived() { console.log('Neville Longbottom');}function theBoyWhoLived() { console.log('Harry Potter');}// 執行theBoyWhoLived();theBoyWhoLived(); 這樣，為什麼兩次執行結果都是Harry Potter是不是就很清楚了呢~","link":"/ioioy77.github.io/2019/10/11/Hoisting/"},{"title":"Vue Instance","text":"前言Vue 音似 View，用意為表示 Vue.js 專注於 View。和其他實作 MVC 的 JavaScript 框架 ( Angular.js、Ember.js ) 相比，Vue.js 屬於 MVVM 設計模式的實作。 MVVM 由 Model–View–ViewModel 組成，使用者看到的是 View，Model 則是資料，View 會和 ViewModel 做資料綁定，然後由 ViewModel 去存取資料，也就是說 View 不會直接存取 Model (資料)，而是由 ViewModel 來做，它是一個同步 View 和 Model 的物件，Vue.js 主要就是在做 ViewModel 的工作。它讓 View 來和它綁定，然後當 Model 發生變化時，自動反應到 View 上。 原生的 JavaScript 或是 jQurey，必須先取得元素才能插入資料，Vue.js 則將 HTML 當成模板，藉由 el 屬性來確認它的執行範圍，然後將資料傳給模板，處理後呈現最後看到的 View。所有 View 的設計，全都在 HTML 中做好，並指定要放資料的區域，Vue.js 便會自動把資料放入其中。 創建實體每個 Vue 的應用皆始於使用 Vue function 建構一個新的 Vue 實體。 123var vm = new Vue({ // options}) 由於受到 MVVM 影響，是以習慣使用變數 vm (ViewModel 的縮寫) 來表示 Vue 實體。 基礎型態實體內 el 參數為 DOM id (指定 id 外不受此實體影響)，data 用於定義屬性：author、series、character，methods 定義函式，可通過 return 返回值，鬍子語法輸出屬性值或函式返回值。 123456789101112131415161718&lt;div id=\"\"&gt; {{ 屬性名稱 }}&lt;/div&gt;new Vue( // 傳入物件 { el: 'DOM id', // data 的值為物件格式或函式，通常會直接用物件，但在計算屬性只能使用函式 data: { // 屬性名稱自訂，用來和 HTML 模板中的 {{ 屬性名稱 }} 相對應。 屬性名稱: '屬性值' }, method: { // 設定 function } }) 實體範例1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue Instance&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"vue_instance\"&gt; &lt;h1&gt;author : {{ author }}&lt;/h1&gt; &lt;h1&gt;series : {{ series }}&lt;/h1&gt; &lt;h1&gt;{{ details() }}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue_instance', data: { author: \"Andrzej Sapkowski\", series: \"The Witcher\", character: [ 'Geralt of Rivia', 'Cirilla Fiona Elen Riannon, the Lion Cub of Cintra' ] }, methods: { details: function() { return this.author + ' writes a series about ' + this.character[0] + ' and ' + this.character[1] + '.'; } } }) &lt;/script&gt;&lt;/body&gt; 運行結果123author : Andrzej Sapkowskiseries : The WitcherAndrzej Sapkowski writes a series about Geralt of Rivia and Cirilla Fiona Elen Riannon, the Lion Cub of Cintra. 響應式狀態當一個 Vue 實體被創建時，它將 data 對象中的所有的屬性加入到 Vue 的響應式系統中。若屬性的值發生改變，頁面將會更新為新的值。 123456789101112var obj = { a: 1 }var vm = new Vue({ data: obj})// 指針相同vm.a === obj.a // true// 修改設置屬性會影響原始數據vm.a = 2obj.a // 2// 無論更動哪方原始數據都會被修改obj.a = 3vm.a // 3 僅有實體被創建時就已經存在於 data 中的屬性才是響應式的。若是之後才新增的屬性，比如： 1vm.b = &apos;I am new！&apos; 則對 b 的改動不會觸發頁面更新。所以一個 Vue 實體在未來所會使用到的所有屬性在最開始時就須全部設定完畢(初始設定為空或不存在：””、0、false、[]、null)。 ※ 使用 Object.freeze() 能阻止修改現有屬性，並導致響應系統無法再追蹤變化。 Vue 所提供的屬性及方法Vue 實體提供了一些能夠被存取的屬性與方法，並以前綴 $ 與用戶自定義的屬性區分。 範例12345678910111213141516171819202122232425262728&lt;div id=\"vm\"&gt; {{a}}&lt;/div&gt;&lt;script&gt;var vm = new Vue({ el: '#vm', data: { a: 'Hello World！' }})// 取得的 el 屬性和用 JavaScript 方法取得的元素相同vm.$el === document.querySelector('#vm') // true// 取得資料物件的屬性console.log(vm.a) // Hello World！// 呼叫 watch 方法，當 a 的值改變時觸發vm.$watch('a', function(newVal, oldVal){ console.log('a 現在是 ' + newVal + ', 之前是' + oldVal) // a 現在是 change！, 之前是 Hello World！})// 模擬 2 秒後改變 a 的值，並觸發 vm.$watch() 方法setTimeout(function(){ vm.a = 'change！'}, 2000)&lt;/script&gt;","link":"/ioioy77.github.io/2020/02/08/Vue Instance/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/ioioy77.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/ioioy77.github.io/tags/Vue/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/ioioy77.github.io/tags/w3HexSchool/"}],"categories":[{"name":"前端學習筆記","slug":"前端學習筆記","link":"/ioioy77.github.io/categories/前端學習筆記/"}]}